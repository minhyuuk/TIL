### 객체지향 설계원칙

앞글자를 따서 **SOLID 원칙**이라 부른다. **총 5가지의 설계원칙**이 존재한다.

---

### SRP (Single Responsibility) 단일 책임 원칙

클래스는 단 한개의 책임을 가져야 한다. 또한 클래스를 변경하는 이유는 단 하나여야 한다.
이를 지키지 않으면, 한 책임의 변경에 의해 다른 책임과 관련된 코드에 영향을 미칠 수 있다.
이렇게 되면 유지보수가 매우 비효율적이다.

> 여기서 말하는 책임은 너무 추상적이다. 책임을 “**기능**” 이라 생각하면 된다. 만약 한 클래스가 수행할 수 있는 책임(기능)이 여러 개라면, 클래스 내부의 함수끼리 강한 결합을 발생시킬 가능성이 높다. 응집도는 높고 결합도는 낮게 만드는 게 객체지향 설계의 핵심인데, 이것이 위반되는 것이다. 새로운 요구사항이나 프로그램 변경에 의해 클래스 내부의 동작들이 연쇄적으로 변경되어야 할 수도 있다. 비효율적으로 설계를 하는 것이기 때문에 책임을 잘 분리하여야 할 필요가 있다.
> 

### OCP (Open - Closed) 개방 폐쇄 원칙

확장에는 Opened(개방), 변경에는 Closed(폐쇄) 되어야 하는 원칙이다.
쉽게 말해서, 기존의 코드를 변경하지 않고 기능을 수정하거나 추가할 수 있도록 설계해야 한다.

어떤 모듈의 기능 하나를 수정할 때, 그 모듈을 이용하는 다른 모듈들 역시 줄줄이 고쳐야 한다면, 유지보수가 복잡해진다. 개방 폐쇄 원칙을 잘 적용해서 기존 코드를 변경하지 않아도 기능을 새롭게 만들거나 변경할 수 있게 하는 것이 중요하다.

그렇지 않으면 객체 지향 프로그래밍의 가장 큰 장점인 유지보수성, 유연성, 재사용성 등을 위반하는 셈이다.
OOP를 사용하는 의미도 사라지게 된다. 

> OCP는 추상화(인터페이스)와 상속(다형성) 등을 통해 구현해낼 수 있다. 자주 변화하는 부분을 추상화함으로써 기존 코드를 수정하지 않고도 기능을 확장할 수 있도록 함으로써 유연함을 높이는 것이 핵심이다.
> 

### LSP (Liskov Substitution) 리스코프 치환 원칙

자식 객체는 부모 객체에서 가능한 행위를 수행할 수 있어야 하는 원칙이다.
즉, 부모 객체를 자식 객체로 치환해도 정상적으로 동작해야 하는 원칙이고,
올바른 상속을 위해 자식 객체의 확장이 부모 객체의 방향을 온전히 따르도록 권고한다.

상속관계에서는 꼭 일반화 관계(IS-A) 가 성립해야 한다. 일관성 있는 관계인지 Check 해야함.
상속관계가 아닌 클래스들을 상속관계로 설정하면, 리스코프 치환 원칙이 위배된다.

### ISP (Interface Segregation) 인터페이스 분리 원칙

클라이언트는 자신이 사용하는 메소드에만 의존해야 한다는 원칙이다.

어떻게 보면 클린 아키텍처 사용하는 이유와 비슷한데, 클린 아키텍처는 모듈을 분리하여 서로 의존성을 떨어뜨리고 하는 일을 분담한다. ISP도 이와 약간 비슷하다. 

한 클래스는 자신이 사용하지 않는 인터페이스는 구현하지 않아야 하고, 인터페이스는 해당 인터페이스를 사용하는 클라이언트를 기준으로 잘게 분리되어야한다.

> 클린 아키텍처의 모듈 분리처럼 각 클라이언트가 필요로 하는 인터페이스를 분리하여 클라이언트가 사용하지 않는 인터페이스에 변경이 발생하더라도 영향을 받지 않도록 만들어야 하는 것이 핵심이다.
> 

### DIP ( Dependency Inversion ) 의존 역전 원칙

의존 관계를 맺을 때, 변하기 쉬운 것(구체적인) 보다는 변하기 어려운 것(추상적인) 에 의존해야 한다는 원칙이다.
구체적인 클래스에 의존하기 보단 추상클래스나 인터페이스에 의존해야 한다는 것이다.