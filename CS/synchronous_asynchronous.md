#### 동기 (Synchronous)
어떤 작업을 요청한 즉시 바로 그 작업의 완료 여부와 처리 결과를 확인할 수 있는 방식이다.
요청한 작업의 완료 여부와 결과를 바로 알 수 있다는 장점이 있다.
하지만 요청한 작업의 완료여부와 작업 결과를 반환받는 데 필요한 시간이 긴 경우 문제가 발생할 수 있다.
해당 작업이 완료되어 결과가 반환될 때 까지 무조건 기다려야만 하기 때문에 짧은 시간이 엄청 많은 대량의 데이터를 요청해 작업을 진행하게 되는 경우, 문제가 발생할 수 있어 주의를 해야 한다.

<br><br>

#### 비동기 (Asynchronous)
동기와 다르게 비동기는 작업을 요청한 즉시 바로 그 작업의 완료 여부와 작업 결과를 바로 확인할 수 없는 방식이다.
요청한 작업의 완료 여부와 반환 값은 콜백 이란 것을 통하여 전달받을 수 있고 이 콜백이 실행되는 시점은 각 작업별로 천차만별이다.
이 방식을 이용하게 되면 이미 요청한 작업의 결과를 기다리고 있을 필요 없이 바로 다음 작업을 요청할 수 있기 때문에 작업 처리 효율이 높아질 수 있다.
하지만 어떤 작업 A 와 B의 경우, A라는 작업이 이루어져야 B라는 작업도 진행할 수 있는 프로그램을 실행하려고 한다면 이를 비동기 방식으로 구현할 경우 프로그램이 다소 복잡해질 수 있어 이 부분에 주의를 해야 한다.

<br><br>

#### 블로킹 (Blocking)
어떤 작업 A와 B라는 작업을 진행할 때 A라는 작업을 진행 중 B 작업을 시작하려 한다면 A의 작업을 잠시 대기시켜두고 B라는 작업을 진행합니다. B라는 작업을 완료했다면 대기시켜놓은 A라는 작업을 진행하는 형식으로 작업이 이루어지는 방식을 말합니다.
블로킹 방식을 사용한다면 작업이 순차적으로 이루어지기 때문에 동작의 흐름을 보기 편하고 이해하기 쉬운 장점이 있다.
하지만 블로킹이 이루어지는 동안 다른 작업을 진행할 수 없어 효율적으로 작업이 진행되지 않는다는 단점이 존재한다.
만약 오래 걸리는 작업을 블로킹 방식으로 처리하게 된다면 굉장히 많은 시간이 걸릴 것이다.

<br><br>

#### 논 블로킹 (Non Blocking)
어떤 작업 A와 B라는 작업을 진행할때 A라는 작업이 진행 중 B 작업을 진행할때 블로킹은 잠시 A 작업을 대기시켜두고 B 작업을 진행했다면 논 블로킹은 이에 상관없이 A 와 B 작업을 수행시키는 것이 가능한 방식을 말한다.
논 블로킹 방식을 사용한다면 동시에 작업이 이루어질 수 있기 때문에 리소스를 효율적으로 사용할 수 있다는 장점이 있다.
하지만 이런 식으로 작업이 진행되면 진행 속도가 빨라 리소스를 효율적으로 이용할 수 있지만 업무의 흐름이 매우 복잡해진다는 단점이 존재한다.
복잡하게 얽히고설킨 작업을 동시에 진행하게 되면 어려운 흐름을 이해하기 힘들 것이다.

<br><br>

#### 뭔가 작업 방식이 비슷한데 똑같은 방식 아닌가?
위의 설명을 보면,
**동기 = 블로킹** / **논블로킹 = 비동기** 라고 생각이 될 것이다.

하지만 이는 완전히 다른 시각을 가지고 바라봐야 한다.
차이점을 꼽자면 관심사의 차이라고 할 수 있다.

**동기/비동기** [데이터]
→ 각 작업이 주고받는 데이터의 흐름을 제어함
***(데이터의 일관성 유지)***

**블로킹/논블로킹** [행동]
→ 각 작업의 수행 형태와 우선순위에 따라 각 작업의 수행 가능 시기를 제어함
***(어떤 작업이 진행되는 시점을 관리)***

데이터의 흐름을 제어하는 것과 작업의 수행 가능 시기를 제어하는 것은 엄연히 다르기 때문에 **동기/비동기** 와 **블로킹/논블로킹** 은 전혀 다른 친구들이라고 생각해야 한다.
